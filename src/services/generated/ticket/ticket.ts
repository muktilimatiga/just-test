/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Lexxadata Customer Scraper API
 * A structured API to search and scrape customer data from the NMS portal.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  HTTPValidationError,
  SearchPayload,
  SearchResponse,
  TicketClosePayload,
  TicketCreateAndProcessPayload,
  TicketCreateOnlyPayload,
  TicketForwardPayload,
  TicketOperationResponse,
  TicketProcessPayload
} from '.././model';





/**
 * @summary Create Ticket Only
 */
export const createTicketOnlyApiV1TicketCreatePost = (
    ticketCreateOnlyPayload: TicketCreateOnlyPayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TicketOperationResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/create`,
      ticketCreateOnlyPayload,options
    );
  }



export const getCreateTicketOnlyApiV1TicketCreatePostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>, TError,{data: TicketCreateOnlyPayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>, TError,{data: TicketCreateOnlyPayload}, TContext> => {

const mutationKey = ['createTicketOnlyApiV1TicketCreatePost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>, {data: TicketCreateOnlyPayload}> = (props) => {
          const {data} = props ?? {};

          return  createTicketOnlyApiV1TicketCreatePost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTicketOnlyApiV1TicketCreatePostMutationResult = NonNullable<Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>>
    export type CreateTicketOnlyApiV1TicketCreatePostMutationBody = TicketCreateOnlyPayload
    export type CreateTicketOnlyApiV1TicketCreatePostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create Ticket Only
 */
export const useCreateTicketOnlyApiV1TicketCreatePost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>, TError,{data: TicketCreateOnlyPayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTicketOnlyApiV1TicketCreatePost>>,
        TError,
        {data: TicketCreateOnlyPayload},
        TContext
      > => {

      const mutationOptions = getCreateTicketOnlyApiV1TicketCreatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Create And Process Ticket
 */
export const createAndProcessTicketApiV1TicketCreateAndProcessPost = (
    ticketCreateAndProcessPayload: TicketCreateAndProcessPayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TicketOperationResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/create-and-process`,
      ticketCreateAndProcessPayload,options
    );
  }



export const getCreateAndProcessTicketApiV1TicketCreateAndProcessPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>, TError,{data: TicketCreateAndProcessPayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>, TError,{data: TicketCreateAndProcessPayload}, TContext> => {

const mutationKey = ['createAndProcessTicketApiV1TicketCreateAndProcessPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>, {data: TicketCreateAndProcessPayload}> = (props) => {
          const {data} = props ?? {};

          return  createAndProcessTicketApiV1TicketCreateAndProcessPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAndProcessTicketApiV1TicketCreateAndProcessPostMutationResult = NonNullable<Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>>
    export type CreateAndProcessTicketApiV1TicketCreateAndProcessPostMutationBody = TicketCreateAndProcessPayload
    export type CreateAndProcessTicketApiV1TicketCreateAndProcessPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Create And Process Ticket
 */
export const useCreateAndProcessTicketApiV1TicketCreateAndProcessPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>, TError,{data: TicketCreateAndProcessPayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAndProcessTicketApiV1TicketCreateAndProcessPost>>,
        TError,
        {data: TicketCreateAndProcessPayload},
        TContext
      > => {

      const mutationOptions = getCreateAndProcessTicketApiV1TicketCreateAndProcessPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Process Ticket Only
 */
export const processTicketOnlyApiV1TicketProcessPost = (
    ticketProcessPayload: TicketProcessPayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TicketOperationResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/process`,
      ticketProcessPayload,options
    );
  }



export const getProcessTicketOnlyApiV1TicketProcessPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>, TError,{data: TicketProcessPayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>, TError,{data: TicketProcessPayload}, TContext> => {

const mutationKey = ['processTicketOnlyApiV1TicketProcessPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>, {data: TicketProcessPayload}> = (props) => {
          const {data} = props ?? {};

          return  processTicketOnlyApiV1TicketProcessPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ProcessTicketOnlyApiV1TicketProcessPostMutationResult = NonNullable<Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>>
    export type ProcessTicketOnlyApiV1TicketProcessPostMutationBody = TicketProcessPayload
    export type ProcessTicketOnlyApiV1TicketProcessPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Process Ticket Only
 */
export const useProcessTicketOnlyApiV1TicketProcessPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>, TError,{data: TicketProcessPayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof processTicketOnlyApiV1TicketProcessPost>>,
        TError,
        {data: TicketProcessPayload},
        TContext
      > => {

      const mutationOptions = getProcessTicketOnlyApiV1TicketProcessPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Close Ticket
 */
export const closeTicketApiV1TicketClosePost = (
    ticketClosePayload: TicketClosePayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TicketOperationResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/close`,
      ticketClosePayload,options
    );
  }



export const getCloseTicketApiV1TicketClosePostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>, TError,{data: TicketClosePayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>, TError,{data: TicketClosePayload}, TContext> => {

const mutationKey = ['closeTicketApiV1TicketClosePost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>, {data: TicketClosePayload}> = (props) => {
          const {data} = props ?? {};

          return  closeTicketApiV1TicketClosePost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CloseTicketApiV1TicketClosePostMutationResult = NonNullable<Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>>
    export type CloseTicketApiV1TicketClosePostMutationBody = TicketClosePayload
    export type CloseTicketApiV1TicketClosePostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Close Ticket
 */
export const useCloseTicketApiV1TicketClosePost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>, TError,{data: TicketClosePayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof closeTicketApiV1TicketClosePost>>,
        TError,
        {data: TicketClosePayload},
        TContext
      > => {

      const mutationOptions = getCloseTicketApiV1TicketClosePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Forward Ticket
 */
export const forwardTicketApiV1TicketForwardPost = (
    ticketForwardPayload: TicketForwardPayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TicketOperationResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/forward`,
      ticketForwardPayload,options
    );
  }



export const getForwardTicketApiV1TicketForwardPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>, TError,{data: TicketForwardPayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>, TError,{data: TicketForwardPayload}, TContext> => {

const mutationKey = ['forwardTicketApiV1TicketForwardPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>, {data: TicketForwardPayload}> = (props) => {
          const {data} = props ?? {};

          return  forwardTicketApiV1TicketForwardPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ForwardTicketApiV1TicketForwardPostMutationResult = NonNullable<Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>>
    export type ForwardTicketApiV1TicketForwardPostMutationBody = TicketForwardPayload
    export type ForwardTicketApiV1TicketForwardPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Forward Ticket
 */
export const useForwardTicketApiV1TicketForwardPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>, TError,{data: TicketForwardPayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof forwardTicketApiV1TicketForwardPost>>,
        TError,
        {data: TicketForwardPayload},
        TContext
      > => {

      const mutationOptions = getForwardTicketApiV1TicketForwardPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Search Ticket
 */
export const searchTicketApiV1TicketSearchPost = (
    searchPayload: SearchPayload, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SearchResponse>> => {
    
    
    return axios.post(
      `/api/v1/ticket/search`,
      searchPayload,options
    );
  }



export const getSearchTicketApiV1TicketSearchPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>, TError,{data: SearchPayload}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>, TError,{data: SearchPayload}, TContext> => {

const mutationKey = ['searchTicketApiV1TicketSearchPost'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>, {data: SearchPayload}> = (props) => {
          const {data} = props ?? {};

          return  searchTicketApiV1TicketSearchPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SearchTicketApiV1TicketSearchPostMutationResult = NonNullable<Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>>
    export type SearchTicketApiV1TicketSearchPostMutationBody = SearchPayload
    export type SearchTicketApiV1TicketSearchPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Search Ticket
 */
export const useSearchTicketApiV1TicketSearchPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>, TError,{data: SearchPayload}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof searchTicketApiV1TicketSearchPost>>,
        TError,
        {data: SearchPayload},
        TContext
      > => {

      const mutationOptions = getSearchTicketApiV1TicketSearchPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    